# -*- coding: utf-8 -*-
"""SF-prac.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12M-VDYEKnK984qlYO6JGdCW6QzQSi3Z4

#Disk scheduling

##FIFO
"""

def fifo_disk_scheduling(cylinders, current_cylinder):
    total_seek_time = 0
    sequence = [current_cylinder]
    for cylinder in cylinders:
        total_seek_time += abs(cylinder - current_cylinder)
        sequence.append(cylinder)
        current_cylinder = cylinder
    return sequence, total_seek_time

def fifo_disk_scheduling(cylindes,current_cylinder):
  sequence=[current_cylinder]
  total_seek_time=0
  for i in range(len(cylinders)):
    total_seek_time+=abs(cylinders[i]-current_cylinder)
    current_cylinder=cylinders[i]
    sequence.append(cylinders[i])
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = fifo_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

import matplotlib.pyplot as plt
movement = [current_cylinder] + cylinders
y=[]
for i in range(len(movement)):
  y.append(i)
plt.plot(movement,y,'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - FIFO Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""##SSTF"""

def sstf_disk_scheduling(cylinders, current_cylinder):
    sequence = [current_cylinder]
    total_seek_time = 0
    while cylinders:
        distances = [abs(cylinder - current_cylinder) for cylinder in cylinders]
        min_distance = min(distances)
        min_index = distances.index(min_distance)
        closest_cylinder = cylinders.pop(min_index)
        sequence.append(closest_cylinder)
        total_seek_time += min_distance
        current_cylinder = closest_cylinder
    return sequence, total_seek_time

def sstf_disk_scheduling(cylinders,current_cylinder):
  total_seek_time=0
  sequence=[current_cylinder]
  while cylinders:
    distances=[abs(cylinder-current_cylinder)for cylinder in cylinders]
    min_dist=min(distances)
    min_index=distances.index(min_dist)
    closest_cylinder=cylinders.pop(min_index)
    current_cylinder=closest_cylinder
    sequence.append(closest_cylinder)
    total_seek_time+=min_dist
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = sstf_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

movement = sequence
y = list(range(len(movement)))
plt.plot(movement, y, 'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - SSTF Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""##SCAN"""

def scan_disk_scheduling(cylinders, current_cylinder):
    sequence = [current_cylinder]
    l1 = cylinders
    for i in range(len(l1)):
        if(l1[i]>current_cylinder):
            sequence.append(l1[i])
    sequence.sort()
    sequence.append(199)
    seq=[]
    for i in range(len(l1)):
        if(l1[i]<current_cylinder):
            seq.append(l1[i])
    seq.sort(reverse=True)
    for i in range(len(seq)):
        sequence.append(seq[i])
    total_seek_time = 0
    for i in range(1, len(sequence)):
        total_seek_time += abs(sequence[i] - sequence[i-1])
    return sequence, total_seek_time

def scan_disk_scheduling(cylinders,current_cylinder):
  sequence = [current_cylinder]
  total_seek_time=0
  seq=[]
  for i in cylinders:
    if(i>current_cylinder):
      sequence.append(i)
    else:
      seq.append(i)
  sequence.sort()
  seq.sort(reverse=True)
  sequence.append(199)
  for i in seq:
    sequence.append(i)
  for i in range(1,len(sequence)):
    total_seek_time+=abs(sequence[i]-sequence[i-1])
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = scan_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

movement = sequence
y = list(range(len(movement)))
plt.plot(movement, y, 'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - SCAN Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""##C-SCAN"""

def c_scan_disk_scheduling(cylinders, current_cylinder):
    sequence = [current_cylinder]
    l1 = cylinders
    for i in range(len(l1)):
        if(l1[i]>current_cylinder):
            sequence.append(l1[i])
    sequence.sort()
    sequence.append(199)
    sequence.append(0)
    seq=[]
    for i in range(len(l1)):
        if(l1[i]>0 and l1[i]<current_cylinder):
            seq.append(l1[i])
    seq.sort()
    for i in range(len(seq)):
        sequence.append(seq[i])
    total_seek_time = 0
    for i in range(1, len(sequence)):
        total_seek_time += abs(sequence[i] - sequence[i-1])
    return sequence, total_seek_time

def c_scan_disk_scheduling(cylinders,current_cylinder):
  sequence = [current_cylinder]
  total_seek_time=0
  seq=[]
  for i in cylinders:
    if(i>current_cylinder):
      sequence.append(i)
    else:
      seq.append(i)
  sequence.sort()
  seq.sort()
  sequence.append(199)
  sequence.append(0)
  for i in seq:
    sequence.append(i)
  for i in range(1,len(sequence)):
    total_seek_time+=abs(sequence[i]-sequence[i-1])
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = c_scan_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

movement = sequence
y = list(range(len(movement)))
plt.plot(movement, y, 'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - SCAN Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""##LOOK"""

def look_disk_scheduling(cylinders, current_cylinder):
    sequence = [current_cylinder]
    l1 = cylinders
    for i in range(len(l1)):
        if(l1[i]>current_cylinder):
            sequence.append(l1[i])
    sequence.sort()
    seq=[]
    for i in range(len(l1)):
        if(l1[i]<current_cylinder):
            seq.append(l1[i])
    seq.sort(reverse=True)
    for i in range(len(seq)):
        sequence.append(seq[i])
    total_seek_time = 0
    for i in range(1, len(sequence)):
        total_seek_time += abs(sequence[i] - sequence[i-1])
    return sequence, total_seek_time

def look_disk_scheduling(cylinders,current_cylinder):
  total_seek_time=0
  sequence=[current_cylinder]
  seq=[]
  for i in cylinders:
    if(i>current_cylinder):
      sequence.append(i)
    else:
      seq.append(i)
  sequence.sort()
  seq.sort(reverse=True)
  for i in seq :
    sequence.append(i)
  for i in range(1,len(sequence)):
    total_seek_time+=abs(sequence[i]-sequence[i-1])
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = look_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

movement = sequence
y = list(range(len(movement)))
plt.plot(movement, y, 'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - SCAN Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""##C-LOOK"""

def c_look_disk_scheduling(cylinders, current_cylinder):
    sequence = [current_cylinder]
    l1 = cylinders
    for i in range(len(l1)):
        if(l1[i]>current_cylinder):
            sequence.append(l1[i])
    sequence.sort()
    seq=[]
    for i in range(len(l1)):
        if(l1[i]<current_cylinder):
            seq.append(l1[i])
    seq.sort()
    for i in range(len(seq)):
        sequence.append(seq[i])
    total_seek_time = 0
    for i in range(1, len(sequence)):
        total_seek_time += abs(sequence[i] - sequence[i-1])
    return sequence, total_seek_time

def c_look_disk_scheduling(cylinders,current_cylinder):
  sequence = [current_cylinder]
  seq=[]
  total_seek_time=0
  for i in cylinders:
    if(i>current_cylinder):
      sequence.append(i)
    else:
      seq.append(i)
  sequence.sort()
  seq.sort()
  for i in seq:
    sequence.append(i)
  for i in range(1,len(sequence)):
    total_seek_time+=abs(sequence[i]-sequence[i-1])
  return sequence,total_seek_time

cylinders = [82,170,43,140,24,16,190]
current_cylinder = 50
sequence, total_seek_time = c_look_disk_scheduling(cylinders, current_cylinder)
print(sequence)
print("Total Seek Time:", total_seek_time)

movement = sequence
y = list(range(len(movement)))
plt.plot(movement, y, 'o-')
plt.xlabel('Cylinder Number')
plt.ylabel('Request Number')
plt.title('Disk Arm Movements - SCAN Disk Scheduling')
plt.gca().invert_yaxis()
plt.show()

"""#memmory allocation"""

def bestFit(blockSize, m, processSize, n):
	allocation = [-1] * n
	for i in range(n):
		bestIdx = -1
		for j in range(m):
			if blockSize[j] >= processSize[i]:
				if bestIdx == -1:
					bestIdx = j
				elif blockSize[bestIdx] > blockSize[j]:
					bestIdx = j
		if bestIdx != -1:
			allocation[i] = bestIdx
			blockSize[bestIdx] -= processSize[i]
	print("Process No. Process Size	 Block no.")
	for i in range(n):
		print(i + 1, "		 ", processSize[i],end = "		 ")
		if allocation[i] != -1:
			print(allocation[i] + 1)
		else:
			print("Not Allocated")

def bestfit(blockSize, m,processSize,n):
  allocation=[-1]*n
  for i in range(n):
    bestIdx=-1
    for j in range(m):
      if(blockSize[j]>=processSize[i]):
        if bestIdx==-1:
          best_Idx=j
        elif blockSize[bestIdx]>blockSize[j]:
          bestIdx=j
    if bestIdx!=-1:
      allocation[i]=bestIdx
      blockSize[bestIdx]-=processSize[i]
  print("process no. Process size Block:")
  for i in range(n):
    print(i + 1,"  ", processSize[i],end ="  ")
    if allocation[i] != -1:
    	print(allocation[i] + 1)
    else:
    	print("Not Allocated")

blockSize = [5,8,4,10]
processSize = [1,4,7]
m = len(blockSize)
n = len(processSize)

bestFit(blockSize, m,processSize,n)

def worstFit(blockSize, m, processSize, n):
	allocation = [-1] * n
	for i in range(n):
		worstIdx = -1
		for j in range(m):
			if blockSize[j] >= processSize[i]:
				if worstIdx == -1:
					worstIdx = j
				elif blockSize[worstIdx] < blockSize[j]:
					worstIdx = j
		if worstIdx != -1:
			allocation[i] = worstIdx
			blockSize[worstIdx] -= processSize[i]
	print("Process No. Process Size	 Block no.")
	for i in range(n):
		print(i + 1, "		 ", processSize[i],
								end = "		 ")
		if allocation[i] != -1:
			print(allocation[i] + 1)
		else:
			print("Not Allocated")

def worstFit(blockSize, m,processSize,n):
  allocation = [-1]*n
  for i in range(n):
    worstIdx=-1
    for j in range(m):
      if blockSize[j]>=processSize[i]:
        if worstIdx==-1:
          worstIdx=j
        elif blockSize[worstIdx]<blockSize[j]:
          worstIdx=j
    if worstIdx!=-1:
      blockSize[worstIdx]-=processSize[i]
      allocation[i]=worstIdx
  print("Process no. Process Size Block no.")
  for i in range(n):
    print(i + 1, "		 ", processSize[i],end = "		 ")
    if worstIdx!=-1:
      print(allocation[i]+1)
    else:
      print("not allocated")

blockSize = [5,8,4,10]
processSize = [1,4,7]
m = len(blockSize)
n = len(processSize)
worstFit(blockSize, m,processSize,n)

def firstFit(blockSize, processSize):
  m = len(blockSize)
  n = len(processSize)
  allocation = [-1] * n
  for i in range(n):
    for j in range(m):
      if blockSize[j] >= processSize[i]:
        allocation[i] = j
        blockSize[j] -= processSize[i]
        break        
  print(" Process No. | Process Size  |   Block no.")
  for i in range(n):
    print("   ", i + 1,"    ", processSize[i],"   ", end ="   ")
    if allocation[i] != -1:
      print(allocation[i] + 1)
    else:
      print("Not Allocated")

blockSize = [5,8,4,10]
processSize = [1,4,7]
m = len(blockSize)
n = len(processSize)
firstFit(blockSize,processSize)

"""#bankers

"""

n=5
m=3
alloc=[[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]
max=[[7, 5, 3], [3, 2, 2], [9, 0, 2], [2, 2, 2], [4, 3, 3]]
avail=[3,3,2]
f=[0]*n
ans=[]
need=[[max[i][j]-alloc[i][j] for j in range(m)]for i in range(n)]
for k in range(n):
  for i in range(n):
    if f[i]==0 and all(need[i][j]<=avail[j] for j in range(m)):
      ans.append(i)
      f[i]=1
      for y in range(m):
        avail[y]+=alloc[i][y]
  if len(ans)==n:
    print("safe sequence is:")
    print("->".join(f"P{p}" for p in ans))
    break
  else:
    print("not safe")

n=5
m=3
alloc=[[0,1,0],[2,0,0],[3,0,2],[2,1,1],[0,0,2]]
max=[[7, 5, 3], [3, 2, 2], [9, 0, 2], [2, 2, 2], [4, 3, 3]]
avail=[3,3,2]
need=[[max[i][j]-alloc[i][j]for j in range(m)]for i in range(n)]
f=[0]*n
ans=[]
for k in range(n):
  for i in range(n):
    if f[i]==0 and all(need[i][j]<=avail[j]for j in range(m)):
      ans.append(i)
      f[i]=1
      for y in range(m):
        avail[y]+=alloc[i][y]
  if (len(ans)==n):
    print("sequence is safe:")
    print("["+"->".join(f"P{p}"for p in ans)+"]")
    break
  else:
    print("not safe")

"""#cache replacement

"""

def LRU(pages, frames):
    page_faults=0
    page_frames = [None] * frames
    page_usage = [-1] * frames
    for i, page in enumerate(pages):
        if page not in page_frames:
            if None in page_frames:
                page_frames[page_frames.index(None)] = page
            else:
                page_frames[page_usage.index(min(page_usage))] = page
            page_faults += 1
        page_usage[page_frames.index(page)] = i
        print(page_frames)
    hit_ratio = 1 - (page_faults / len(pages))
    return page_faults, hit_ratio

pages = [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2]
frames = 4
faults, hit_ratio = LRU(pages, frames)
print(f"Number of Page Faults using LRU: {faults}")
print(f"Hit Ratio using LRU {hit_ratio}")

def Optimal(pages, frame):
    page_faults = 0
    page_frames = [None] * frame
    for i, page in enumerate(pages):
        if page not in page_frames:
            if None in page_frames:
                page_frames[page_frames.index(None)] = page
            else:
                replace = max(page_frames, key=lambda x: pages[i+1:].index(x) if x in pages[i+1:] else float('inf'))
                page_frames[page_frames.index(replace)] = page
            page_faults += 1
        print(page_frames)
    hit_ratio = 1 - (page_faults / len(pages))
    return page_faults, hit_ratio

pages = [7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2]
frame = 4
page_faults, hit_ratio = Optimal(pages, frame)
print(f"Number of Page page_Faults using Optimal: {page_faults}")
print(f"Hit Ratio using Optimal {hit_ratio}")

def FIFO(pages, frames):
    page_faults = 0
    page_frames = [None] * frames
    frame_pointer = 0

    for page in pages:
        if page not in page_frames:
            page_frames[frame_pointer] = page
            frame_pointer = (frame_pointer + 1) % frames
            page_faults += 1
        print(page_frames)
    
    hit_ratio = 1 - (page_faults / len(pages))
    return page_faults, hit_ratio
pages_string=[1,3,0,3,5,6]
page_frames=3
faults,hitratio=FIFO(pages_string,page_frames)  
print(f"Number of Page Faults using FIFO: {faults}")
print(f"Hit Ratio using FIFO {hitratio}")

def FIFO(pages, frames):
    page_faults=0
    page_frames=[None]*frames
    frame_pointer=0   


    for page in pages:
        if page not in page_frames:
            page_frames[frame_pointer]=page
            frame_pointer=(frame_pointer+1)%frames
            page_faults+=1
        print(page_frames)

    hit_ratio=1-(page_faults/len(pages))
    return page_faults,hit_ratio
pages_string=[1,3,0,3,5,6]
page_frames=3
faults,hitratio=FIFO(pages_string,page_frames)  
print(f"Number of Page Faults using FIFO: {faults}")
print(f"Hit Ratio using FIFO {hitratio}")

"""#Booths"""

def twos_comp(bin_x):
  fa=''
  for i in bin_x:
    if(i=='0'):
      fa=fa+'1'
    else:
      fa=fa+'0'
  return bin(int(fa,2)+int('1',2)).replace('0b','')

def add(x,y,count):
  sum=bin(int(x,2)+int(y,2)).replace('0b','')
  if(len(sum)<count):
    sum='0'*(count-len(sum))+sum
  if(len(sum)>count):
    sum=sum[(len(sum)-count):]
  return sum

x=int(input('Enter number 1'))
y=int(input('Enter number 2'))
if(x>0 and y>0):
  count=max(len(bin(x).replace('0b','')),len(bin(y).replace('0b','')))+1
elif(x<0 and y<0):
  count=max(len(bin(abs(x)).replace('0b','')),len(bin(abs(y)).replace('0b','')))+1
elif(x<0 or y<0):
  if(x<0):
    if(len(bin(y).replace('0b',''))>len(bin(abs(x)).replace('0b',''))):
      count=len(bin(y).replace('0b',''))
    else:
      count=len(bin(abs(x)).replace('0b',''))+1
  elif(y<0):
    if(len(bin(x).replace('0b',''))>len(bin(abs(y)).replace('0b',''))):
      count=len(bin(x).replace('0b',''))
    else:
      count=len(bin(abs(y)).replace('0b',''))+1
temp_x=bin(abs(x)).replace('0b','')
temp_y=bin(abs(y)).replace('0b','')
if(len(temp_x)<count):
  bin_x='0'*(count-len(temp_x))+temp_x
if(len(temp_y)<count):
  bin_y='0'*(count-len(temp_y))+temp_y
if(x<0):
  bin_x=twos_comp(bin_x)
if(y<0):
  bin_y=twos_comp(bin_y)
M=bin_x
Q=bin_y
A='0'*count
q1='0'
print(A+'  '+Q+'  '+q1)
for i in range(count):
  if((Q[count-1]+q1)=='01'):
    print('Adding A and M')
    A=add(A,M,count)
    print(A+'  '+Q+'  '+q1)
  elif((Q[count-1]+q1)=='10'):
    print('Subtracting M from A')
    A=add(A,twos_comp(M),count)
    print(A+'  '+Q+'  '+q1)
  print('Right Shifting')
  length=len(A+Q+q1)
  if(A[0]=='1'):
    temp='1'+bin(int((A+Q+q1),2)>>1).replace('0b','')
  else:
    temp=bin(int((A+Q+q1),2)>>1).replace('0b','')
  if(len(temp)<length):
    temp='0'*(length-len(temp))+temp
  A=temp[0:count]
  Q=temp[count:2*count]
  q1=temp[2*count:]
  print(A+'  '+Q+'  '+q1)

if(x<0 and y<0):
  print('Final Answer is:',int(A+Q,2))
elif(x<0 or y<0):
  print('Final Answer is:',-1*int(twos_comp(A+Q),2))
else:
  print('Final Answer is:',int((A+Q),2))

"""#CPU Scheduling"""

class processes:
	def __init__(self, id, at, bt, ct):
		self.id = id
		self.at = at
		self.bt = bt
		self.ct = ct
		self.tat = self.ct-self.at
		self.wt = self.tat-self.bt

	def get(self):
		print(f"{self.id}\t{self.at}\t{self.bt}\t{self.ct}\t{self.tat}\t{self.wt}")

	def turnaround(self):
		return self.tat

	def waiting(self):
		return self.wt


num = int(input("Enter the Number of Processes:"))
l = []
ct = 0

for i in range(num):

	print(f'Process {i+1}')
	at = int(input("Enter the Arrival Time:-"))
	bt = int(input("Enter the Burst Time:-"))
	ct += bt
	l.append(processes(i, at, bt, ct))

	print("\n")
avg_tat = 0
avg_wat = 0
print("PID\tAT\tBT\tCT\tTAT\tWT")
for process in l:
	process.get()

for process in l:
	avg_tat += process.turnaround()
	avg_wat += process.waiting()
print(f"\nAvg_turnaround:{avg_tat/num}\nAvg_Waitingtime:{avg_wat/num}")

# pid at bt
# 0 0 5
# 1 2 3
# 2 6 2
# 3 7 3

class Process:
    def __init__(self, pid, at, bt):
        self.pid = pid
        self.at = at
        self.bt = bt
        self.ct = None
        self.tat = None
        self.wt = None

    def get(self):
        print(f"{self.pid}\t{self.at}\t{self.bt}\t{self.ct}\t{self.tat}\t{self.wt}")

    def turnaround(self):
        return self.tat

    def waiting(self):
        return self.wt


num = int(input("Enter the Number of Processes:"))
l = []

for i in range(num):
    print(f'Process {i+1}')
    at = 0  # assuming all processes arrive at time 0
    bt = int(input("Enter the Burst Time: "))
    l.append(Process(i, at, bt))

l.sort(key=lambda x: x.bt)  # sort processes based on burst time
ct = 0
for process in l:
    ct += process.bt
    process.ct = ct
    process.tat = process.ct - process.at
    process.wt = process.tat - process.bt

avg_tat = sum(process.turnaround() for process in l) / num
avg_wat = sum(process.waiting() for process in l) / num

print("PID\tAT\tBT\tCT\tTAT\tWT")
for process in l:
    process.get()

print(f"\nAvg_turnaround: {avg_tat:.2f}\nAvg_Waitingtime: {avg_wat:.2f}")

class Process:
  def __init__(self,id,at,bt):
    self.id=id
    self.at=at
    self.bt=bt
    self.ct=None
    self.tat=None
    self.wt=None
  def get(self):
    print(f"{self.id}\t\t{self.at}\t\t{self.bt}\t\t{self.ct}\t\t{self.tat}\t\t{self.wt}")
  def turnaround(self):
    return self.tat
  def waiting(self):
    return self.wt
num= int(input("enter the number of processes:"))
l=[]
for i in range(num):
    print(f'Process {i+1}')
    at = 0  # assuming all processes arrive at time 0
    bt = int(input("Enter the Burst Time: "))
    l.append(Process(i, at, bt))
l.sort(key = lambda x : x.bt)
ct=0
for process in l:
  ct+=process.bt
  process.ct=ct
  process.tat=process.ct-process.at
  process.wt=process.tat-process.bt
print("id\t\tat\t\tbt\t\tct\t\ttat\t\twt")
for process in l:
  process.get()

avg_tat=sum(process.turnaround()for process in l)/num
avg_wt=sum(process.waiting()for process in l)/num
print(f"Avg turnaround time is{avg_tat} and avg waiting time is:{avg_wt}")

class Process:
    def __init__(self, pid, at, bt, priority):
        self.pid = pid
        self.at = at
        self.bt = bt
        self.priority = priority
        self.ct = None
        self.tat = None
        self.wt = None

    def get(self):
        print(f"{self.pid}\t\t{self.at}\t\t{self.bt}\t{self.priority}\t{self.ct}\t{self.tat}\t{self.wt}")

    def turnaround(self):
        return self.tat

    def waiting(self):
        return self.wt


num = int(input("Enter the Number of Processes: "))
l = []

for i in range(num):
    print(f'Process {i+1}')
    at = int(input("Enter the Arrival Time: "))
    bt = int(input("Enter the Burst Time: "))
    priority = int(input("Enter the Priority: "))
    l.append(Process(i, at, bt, priority))

l.sort(key=lambda x: x.priority)  # sort processes based on priority
ct = 0
for process in l:
    if process.at > ct:
        ct = process.at
    ct += process.bt
    process.ct = ct
    process.tat = process.ct - process.at
    process.wt = process.tat - process.bt

avg_tat = sum(process.turnaround() for process in l) / num
avg_wat = sum(process.waiting() for process in l) / num

print("PID\tAT\tBT\tPriority\tCT\tTAT\tWT")
for process in l:
    process.get()

print(f"\nAvg_turnaround: {avg_tat:.2f}\nAvg_Waitingtime: {avg_wat:.2f}")